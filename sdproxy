#!/usr/bin/python

import os
import sys
import argparse
import socket
import time
import logging

import gevent
from gevent import select
from gevent import monkey; monkey.patch_all()

last_data = time.time()

class Timeout(Exception):
    pass

def parse_args():
    p = argparse.ArgumentParser()
    p.add_argument('--wait-timeout', '-w',
                   type=int,
                   help=('Time to wait for remote to '
                         'become active before exiting '
                         'with an error.'))
    p.add_argument('--connect-timeout', '-c',
                   type=int,
                   default=10,
                   help=('Time to wait for a single '
                         'connection to remote.'))
    p.add_argument('--idle-timeout', '-t',
                   type=int,
                   help=('If there is no activity after '
                         'this many seconds the proxy '
                         'will exit.'))
    p.add_argument('--debug', '-d',
                   action='store_const',
                   const=logging.DEBUG,
                   dest='loglevel')
    p.add_argument('--verbose', '-v',
                   action='store_const',
                   const=logging.INFO,
                   dest='loglevel')
    p.add_argument('remotehost')
    p.add_argument('remoteport',
                   type=int)
    p.set_defaults(loglevel=logging.WARN)
    return p.parse_args()

def wait_for_active():
    start_wait = time.time()

    while True:
        now = time.time()
        wait_time = now - start_wait

        try:
            s = socket.create_connection(
                (args.remotehost, args.remoteport),
                timeout=args.connect_timeout)
            logging.debug('remote is active after %d seconds', wait_time)
            return s
        except (socket.error, socket.timeout) as detail:
            logging.debug('waiting %d seconds for remote to become active',
                         wait_time)
            if args.wait_timeout and wait_time > args.wait_timeout:
                raise Timeout()

            # Sleep 1 second on errors to avoid spinning on
            # 'connection refused'
            if isinstance(detail, socket.error):
                time.sleep(1)

def proxy_data(clisock, remsock, cliaddr):
    global last_data

    from_client = []
    from_remote = []

    rfdlist = [clisock, remsock]

    while True:
        wfdlist = set()

        if from_client:
            wfdlist.add(remsock)
        if from_remote:
            wfdlist.add(clisock)

        # We have to use select because (a) nothing else seems to be cross
        # platform, and (b) gevent only provides select().
        rfds, wfds, xfds = select.select(rfdlist,
                                         list(wfdlist),
                                         [])

        if clisock in wfds:
            clisock.send(from_remote.pop(0))
        if remsock in wfds:
            remsock.send(from_client.pop(0))
        
        if clisock in rfds:
            data = clisock.recv(8192)
            logging.debug('read %d bytes from client', len(data))
            if not data:
                break

            last_data = time.time()
            from_client.append(data)
        
        if remsock in rfds:
            data = remsock.recv(8192)
            logging.debug('read %d bytes from remote', len(data))
            if not data:
                break

            last_data = time.time()
            from_remote.append(data)

def channel(clisock, cliaddr):
    '''Handles a single connection between a client and the remote server
    for which we are acting as a proxy.'''

    remsock = None

    try:
        logging.debug('starting channel for client %s', cliaddr)
        remsock = wait_for_active()
        proxy_data(clisock, remsock, cliaddr)
    except Timeout:
        logging.debug('timed out waiting for remote to become active')
    finally:
        logging.info('closing channel for client %s', cliaddr)
        clisock.close()
        if remsock is not None:
            remsock.close()

def main():
    global args

    args = parse_args()
    logging.basicConfig(
        level = args.loglevel)

    listenfds = int(os.environ.get('LISTEN_FDS', 0))
    assert(listenfds == 1)

    listener = socket.fromfd(3, socket.AF_INET, socket.SOCK_STREAM)

    logging.info('starting main loop')
    while True:
        rfds, wfds, xfds = select.select([listener], [], [], 10)
        if listener in rfds:
            clisock, cliaddr = listener.accept()
            logging.info('new connection from %s', cliaddr)
            gevent.spawn(channel, clisock, cliaddr)

        if not rfds:
            now = time.time()
            idletime = now-last_data
            logging.debug('idle check (%d)', idletime)
            if args.idle_timeout and (idletime > args.idle_timeout):
                logging.info('idle time exceeded')
                break

if __name__ == '__main__':
    main()

